<script>

// TODO(sjmiles): when binding properties that are themselves bound,
// we need to do a merge, which increases the complexity considerably.
// Is there a different way to frame this problem?

// TODO(sjmiles): implement dispose

function Datum(value) {
  this.value = value;
  // we require back references so we can merge datums
  // back references will require dispose pattern for GC,
  // but then we already have this problem wrt watchers
  // a 'referer' must be a DataClient
  this.referers = [];
}

Datum.prototype = {
  addReferer: function(client, name) {
    this.referers.push({client: client, name: name});
  },
  setValue: function(value) {
    var old = this.value;
    if (old !== value) {
      this.value = value;
      this.notify(old);
    }
  },
  notify: function(old) {
    if (this.watchers) {
      var value = this.value;
      this.watchers.forEach(function(w) {
        w(value, old);
      });
    }
  },
  watch: function(notifier) {
    if (!this.watchers) {
      this.watchers = [];
    }
    this.watchers.push(notifier);
  },
  merge: function(other) {
    // transfer all watchers of `other` to `this`
    if (other.watchers) {
      this.watchers = (this.watchers || []).concat(other.watchers);
      other.watchers = null;
    }
    // redirect all referers of `other` to `this`
    var referers = other.referers;
    if (referers.length) {
      referers.forEach(function(r) {
        r.client._refer(r.name, this);
      }, this);
      other.referers = null;
    }
    // `other` should be free to GC at this point    
  }
};

DataClient = {
  published: [],
  watched: {},
  computed: {},
  init: function() {
    this._data = {};
    this.publishProperties(this.published);
    this.watchProperties(this.watched);
    this.defineComputedProperties(this.computed);
  },
  publishProperties: function(properties) {
    properties.forEach(this.publishProperty, this)
  },
  publishProperty: function(property) {
    this._defineProperty(property);
    var watchName = property + 'Changed';
    // TODO(sjmiles): either test is extremely slow, perhaps
    // we remove this feature, and instead have elements
    // generate watches from a list precomputed at registration time
    //if (watchName in this) {
    if (this[watchName]) {
      this.watch(property, this[watchName]);
    }
  },
  notifyChange: function(name) {
    var datum = this._data[name];
    datum.notify(datum.value);
  },
  watch: function(name, notify) {
    this._data[name].watch(notify.bind(this));
  },
  watchProperties: function(properties) {
    for (var n in properties) {
      this.compoundWatch(n.split(' '), this[properties[n]]);
    }
  },
  defineComputedProperties: function(computed) {
    for (var n in computed) {
      this.defineComputedProperty(n, computed[n]);
    }
  },
  defineComputedProperty: function(name, expression) {
    this.publishProperty(name);
    var parts = expression.match(/(.*)\((.*)\)/); 
    var method = this[parts[1]];
    var args = parts[2].replace(/ /g, '').split(',');
    this.compoundWatch(args, function() {
      Polymer.log.watches && console.log('[defineComputedProperty]: computing [%s]', name, arguments);
      // this.filtered = this.computeFiltered(items, filtered)
      this[name] = method.apply(this, arguments);
    });
  },
  compoundWatch: function(names, notify) {
    // TODO(sjmiles): needs factoring
    // fallback to normal watch if we are not truly compound
    if (names.length === 1) {
      this.watch(names[0], notify);
      return;
    }
    var debouncing = false, 
        data = this._data,
        async = this.async.bind(this),
        client = this
        ;
    names.forEach(function(n) {
      data[n].watch(function(value) {
        Polymer.log.watches && console.log('[compoundWatch]: debounce [%s]', n);
        if (!debouncing) {
          debouncing = true;
          // TODO(sjmiles): if a property in `name` is itself computed 
          // we fail to debounce properly. 
          // I don't see how we can debounce properly unless we study
          // the dependency graph. :(
          async(function() {
            debouncing = false;
            var args = [];
            names.forEach(function(n) {
              args.push(client[n])
            });
            Polymer.log.watches && console.log('[compoundWatch]: async-notify ', names, args);
            notify.apply(client, args);
          });
        } 
      });
    });
  },
  // cause this[name] and target[targetName] to refer to the same datum
  // TODO(sjmiles): change call signature to (name, target[, targetName])
  bindProperty: function(name, targetName, target) {
    //
    // TODO(sjmiles): which datum is 'old' and which is 'new' is arbitrary atm 
    // (one value is discarded)
    //
    // merge old into new
    target._data[targetName].merge(this._data[name], name);
  },
  async: function(method) {
    var handled = false;
    var handle = function() {
      if (!handled) {
        handled = true;
        method.call(this);
      }
    }.bind(this);
    // minimize latency by racing requests
    setTimeout(handle);
    requestAnimationFrame(handle);
  },
  _defineProperty: function(name) {
    if (!(name in this._data)) {
      this._refer(name, new Datum(null));
      // install accessors on our prototype (if needed)
      Object.getPrototypeOf(this)._defineAccessors(name);
    }
  },
  _defineAccessors: function(name) {
    if (!this.hasOwnProperty(name)) {
      Object.defineProperty(this, name, {
        get: function() {
          return this._data[name].value;
        },
        set: function(value) {
          this._data[name].setValue(value);
        }
      });      
    }
  },
  _refer: function(name, datum) {
    this._data[name] = datum;
    datum.addReferer(this, name);
  }
};

Base.features.push(DataClient);

</script>